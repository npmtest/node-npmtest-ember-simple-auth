{"/home/travis/build/npmtest/node-npmtest-ember-simple-auth/test.js":"/* istanbul instrument in package npmtest_ember_simple_auth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/lib.npmtest_ember_simple_auth.js":"/* istanbul instrument in package npmtest_ember_simple_auth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_simple_auth = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_simple_auth = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-simple-auth && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_simple_auth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_simple_auth\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_simple_auth.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_simple_auth.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_simple_auth.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_simple_auth.__dirname + '/lib.npmtest_ember_simple_auth.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/index.js":"'use strict';\n\n/* eslint-env node */\n/* eslint-disable no-var, object-shorthand, prefer-template */\n\nvar writeFile = require('broccoli-file-creator');\nvar version = require('./package.json').version;\n\nmodule.exports = {\n  name: 'ember-simple-auth',\n\n  included: function() {\n    this._super.included.apply(this, arguments);\n    this._ensureThisImport();\n\n    this.import('vendor/ember-simple-auth/register-version.js');\n  },\n\n  treeForVendor: function() {\n    var content = 'Ember.libraries.register(\\'Ember Simple Auth\\', \\'' + version + '\\');';\n    return writeFile('ember-simple-auth/register-version.js', content);\n  },\n\n  _ensureThisImport: function() {\n    if (!this.import) {\n      this._findHost = function findHostShim() {\n        var current = this;\n        var app;\n        do {\n          app = current.app || app;\n        } while (current.parent.parent && (current = current.parent));\n        return app;\n      };\n      this.import = function importShim(asset, options) {\n        var app = this._findHost();\n        app.import(asset, options);\n      };\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/.eslintrc.js":"module.exports = {\n  root: true,\n  extends: [\n    'simplabs',\n    'simplabs/plugins/ember',\n  ],\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/configuration.js":"import Ember from 'ember';\n\nconst { getWithDefault, typeOf, deprecate } = Ember;\n\nconst DEFAULTS = {\n  baseURL:                     '',\n  authenticationRoute:         'login',\n  routeAfterAuthentication:    'index',\n  routeIfAlreadyAuthenticated: 'index'\n};\n\n/**\n  Ember Simple Auth's configuration object.\n\n  To change any of these values, set them on the application's environment\n  object, e.g.:\n\n  ```js\n  // config/environment.js\n  ENV['ember-simple-auth'] = {\n    baseURL: 'path/to/base/url'\n  };\n  ```\n\n  @class Configuration\n  @extends Object\n  @module ember-simple-auth/configuration\n  @public\n*/\nexport default {\n  /**\n    The base URL of the application as configured in `config/environment.js`.\n\n    @property baseURL\n    @readOnly\n    @static\n    @type String\n    @default ''\n    @public\n  */\n  baseURL: DEFAULTS.baseURL,\n\n  /**\n    The route to transition to for authentication. The\n    {{#crossLink \"AuthenticatedRouteMixin\"}}{{/crossLink}} will transition to\n    this route when a route that implements the mixin is accessed when the\n    route is not authenticated.\n\n    @property authenticationRoute\n    @deprecated AuthenticatedRouteMixin/authenticationRoute:property\n    @readOnly\n    @static\n    @type String\n    @default 'login'\n    @public\n  */\n  authenticationRoute: DEFAULTS.authenticationRoute,\n\n  /**\n    The route to transition to after successful authentication.\n\n    @property routeAfterAuthentication\n    @deprecated ApplicationRouteMixin/routeAfterAuthentication:property\n    @readOnly\n    @static\n    @type String\n    @default 'index'\n    @public\n  */\n  routeAfterAuthentication: DEFAULTS.routeAfterAuthentication,\n\n  /**\n    The route to transition to if a route that implements the\n    {{#crossLink \"UnauthenticatedRouteMixin\"}}{{/crossLink}} is accessed when\n    the session is authenticated.\n\n    @property routeIfAlreadyAuthenticated\n    @deprecated UnauthenticatedRouteMixin/routeIfAlreadyAuthenticated:property\n    @readOnly\n    @static\n    @type String\n    @default 'index'\n    @public\n  */\n  routeIfAlreadyAuthenticated: DEFAULTS.routeIfAlreadyAuthenticated,\n\n  load(config) {\n    for (let property in this) {\n      if (this.hasOwnProperty(property) && typeOf(this[property]) !== 'function') {\n        if (['authenticationRoute', 'routeAfterAuthentication', 'routeIfAlreadyAuthenticated'].indexOf(property) >= 0 && DEFAULTS[property] !== this[property]) {\n          deprecate(`Ember Simple Auth: ${property} should no longer be overridden in the configuration. Instead, override the ${property} property in the route.`, false, {\n            id: `ember-simple-auth.configuration.routes`,\n            until: '2.0.0'\n          });\n        }\n\n        this[property] = getWithDefault(config, property, DEFAULTS[property]);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/internal-session.js":"import Ember from 'ember';\n\nconst {\n  RSVP,\n  isNone,\n  isEmpty,\n  ObjectProxy,\n  Evented,\n  assign: emberAssign,\n  merge,\n  assert,\n  deprecate,\n  set,\n  debug,\n  getOwner\n} = Ember;\nconst assign = emberAssign || merge;\n\nexport default ObjectProxy.extend(Evented, {\n  authenticator:       null,\n  store:               null,\n  isAuthenticated:     false,\n  attemptedTransition: null,\n\n  init() {\n    this._super(...arguments);\n    this.set('content', { authenticated: {} });\n    this._busy = false;\n    this._bindToStoreEvents();\n  },\n\n  authenticate(authenticatorFactory, ...args) {\n    this._busy = true;\n    assert(`Session#authenticate requires the authenticator to be specified, was \"${authenticatorFactory}\"!`, !isEmpty(authenticatorFactory));\n    const authenticator = this._lookupAuthenticator(authenticatorFactory);\n    assert(`No authenticator for factory \"${authenticatorFactory}\" could be found!`, !isNone(authenticator));\n\n    return authenticator.authenticate(...args).then((content) => {\n      this._busy = false;\n      return this._setup(authenticatorFactory, content, true);\n    }, (error) => {\n      const rejectWithError = () => RSVP.Promise.reject(error);\n\n      this._busy = false;\n      return this._clear().then(rejectWithError, rejectWithError);\n    });\n  },\n\n  invalidate() {\n    this._busy = true;\n    assert('Session#invalidate requires the session to be authenticated!', this.get('isAuthenticated'));\n\n    let authenticator = this._lookupAuthenticator(this.authenticator);\n    return authenticator.invalidate(this.content.authenticated, ...arguments).then(() => {\n      authenticator.off('sessionDataUpdated');\n      this._busy = false;\n      return this._clear(true);\n    }, (error) => {\n      this.trigger('sessionInvalidationFailed', error);\n      this._busy = false;\n      return RSVP.Promise.reject(error);\n    });\n  },\n\n  restore() {\n    this._busy = true;\n    const reject = () => RSVP.Promise.reject();\n\n    return this._callStoreAsync('restore').then((restoredContent) => {\n      let { authenticator: authenticatorFactory } = restoredContent.authenticated || {};\n      if (authenticatorFactory) {\n        delete restoredContent.authenticated.authenticator;\n        const authenticator = this._lookupAuthenticator(authenticatorFactory);\n        return authenticator.restore(restoredContent.authenticated).then((content) => {\n          this.set('content', restoredContent);\n          this._busy = false;\n          return this._setup(authenticatorFactory, content);\n        }, (err) => {\n          debug(`The authenticator \"${authenticatorFactory}\" rejected to restore the session - invalidating…`);\n          if (err) {\n            debug(err);\n          }\n          this._busy = false;\n          return this._clearWithContent(restoredContent).then(reject, reject);\n        });\n      } else {\n        delete (restoredContent || {}).authenticated;\n        this._busy = false;\n        return this._clearWithContent(restoredContent).then(reject, reject);\n      }\n    }, () => {\n      this._busy = false;\n      return this._clear().then(reject, reject);\n    });\n  },\n\n  _callStoreAsync(method, ...params) {\n    const result = this.store[method](...params);\n\n    if (typeof result === 'undefined' || typeof result.then === 'undefined') {\n      deprecate(`Ember Simple Auth: Synchronous stores have been deprecated. Make sure your custom store's ${method} method returns a promise.`, false, {\n        id: `ember-simple-auth.session-store.synchronous-${method}`,\n        until: '2.0.0'\n      });\n      return RSVP.Promise.resolve(result);\n    } else {\n      return result;\n    }\n  },\n\n  _setup(authenticator, authenticatedContent, trigger) {\n    trigger = Boolean(trigger) && !this.get('isAuthenticated');\n    this.beginPropertyChanges();\n    this.setProperties({\n      isAuthenticated: true,\n      authenticator\n    });\n    set(this.content, 'authenticated', authenticatedContent);\n    this._bindToAuthenticatorEvents();\n\n    return this._updateStore().then(() => {\n      this.endPropertyChanges();\n      if (trigger) {\n        this.trigger('authenticationSucceeded');\n      }\n    }, () => {\n      this.setProperties({\n        isAuthenticated: false,\n        authenticator: null\n      });\n      set(this.content, 'authenticated', {});\n      this.endPropertyChanges();\n    });\n  },\n\n  _clear(trigger) {\n    trigger = Boolean(trigger) && this.get('isAuthenticated');\n    this.beginPropertyChanges();\n    this.setProperties({\n      isAuthenticated: false,\n      authenticator:   null\n    });\n    set(this.content, 'authenticated', {});\n\n    return this._updateStore().then(() => {\n      this.endPropertyChanges();\n      if (trigger) {\n        this.trigger('invalidationSucceeded');\n      }\n    }, () => this.endPropertyChanges());\n  },\n\n  _clearWithContent(content, trigger) {\n    this.set('content', content);\n    return this._clear(trigger);\n  },\n\n  setUnknownProperty(key, value) {\n    assert('\"authenticated\" is a reserved key used by Ember Simple Auth!', key !== 'authenticated');\n    let result = this._super(key, value);\n    if (!(/^_/).test(key)) {\n      this._updateStore();\n    }\n    return result;\n  },\n\n  _updateStore() {\n    let data = this.content;\n    if (!isEmpty(this.authenticator)) {\n      set(data, 'authenticated', assign({ authenticator: this.authenticator }, data.authenticated || {}));\n    }\n    return this._callStoreAsync('persist', data);\n  },\n\n  _bindToAuthenticatorEvents() {\n    const authenticator = this._lookupAuthenticator(this.authenticator);\n    authenticator.off('sessionDataUpdated');\n    authenticator.off('sessionDataInvalidated');\n    authenticator.on('sessionDataUpdated', (content) => {\n      this._setup(this.authenticator, content);\n    });\n    authenticator.on('sessionDataInvalidated', () => {\n      this._clear(true);\n    });\n  },\n\n  _bindToStoreEvents() {\n    this.store.on('sessionDataUpdated', (content) => {\n      if (!this._busy) {\n        this._busy = true;\n        let { authenticator: authenticatorFactory } = (content.authenticated || {});\n        if (authenticatorFactory) {\n          delete content.authenticated.authenticator;\n          const authenticator = this._lookupAuthenticator(authenticatorFactory);\n          authenticator.restore(content.authenticated).then((authenticatedContent) => {\n            this.set('content', content);\n            this._busy = false;\n            this._setup(authenticatorFactory, authenticatedContent, true);\n          }, (err) => {\n            debug(`The authenticator \"${authenticatorFactory}\" rejected to restore the session - invalidating…`);\n            if (err) {\n              debug(err);\n            }\n            this._busy = false;\n            this._clearWithContent(content, true);\n          });\n        } else {\n          this._busy = false;\n          this._clearWithContent(content, true);\n        }\n      }\n    });\n  },\n\n  _lookupAuthenticator(authenticator) {\n    return getOwner(this).lookup(authenticator);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/config/environment.js":"'use strict';\n\n/* eslint-env node */\n/* eslint-disable no-var, object-shorthand */\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authenticators/base.js":"import Ember from 'ember';\n\nconst { RSVP, Evented, Object: EmberObject } = Ember;\n\n/**\n  The base class for all authenticators. __This serves as a starting point for\n  implementing custom authenticators and must not be used directly.__\n\n  The authenticator authenticates the session. The actual mechanism used to do\n  this might, e.g., post a set of credentials to a server and in exchange\n  retrieve an access token, initiating authentication against an external\n  provider like Facebook, etc. The details depend on the specific authenticator.\n  Upon successful authentication, any data that the authenticator receives and\n  resolves via the promise returned from the\n  {{#crossLink \"BaseAuthenticator/authenticate:method\"}}{{/crossLink}}\n  method is stored in the session and can be accessed via the session service\n  to be used by the authorizer (see\n  {{#crossLink \"BaseAuthorizer/authorize:method\"}}{{/crossLink}}) to e.g.,\n  authorize outgoing requests.\n\n  The authenticator also decides whether a set of data that was restored from\n  the session store (see\n  {{#crossLink \"BaseStore/restore:method\"}}{{/crossLink}}) makes up an\n  authenticated session or not.\n\n  __Authenticators for an application are defined in the `app/authenticators`\n  directory__, e.g.:\n\n  ```js\n  // app/authenticators/oauth2.js\n  import OAuth2PasswordGrantAuthenticator from 'ember-simple-auth/authenticators/oauth2-password-grant';\n\n  export default OAuth2PasswordGrantAuthenticator.extend({\n    ...\n  });\n  ```\n\n  and can then be used via the name Ember CLI automatically registers for them\n  within the Ember container.\n\n  ```js\n  // app/components/login-form.js\n  export default Ember.Controller.extend({\n    session: Ember.inject.service(),\n\n    actions: {\n      authenticate: function() {\n        this.get('session').authenticate('authenticator:oauth2');\n      }\n    }\n  });\n  ```\n\n  @class BaseAuthenticator\n  @module ember-simple-auth/authenticators/base\n  @extends Ember.Object\n  @uses Ember.Evented\n  @public\n*/\nexport default EmberObject.extend(Evented, {\n  /**\n    __Triggered when the authentication data is updated by the authenticator\n    due to an external or scheduled event__. This might happen, e.g., if the\n    authenticator refreshes an expired token or an event is triggered from an\n    external authentication provider that the authenticator uses. The session\n    handles that event, passes the updated data back to the authenticator's\n    {{#crossLink \"BaseAuthenticator/restore:method\"}}{{/crossLink}}\n    method and handles the result of that invocation accordingly.\n\n    @event sessionDataUpdated\n    @param {Object} data The updated session data\n    @public\n  */\n\n  /**\n    __Triggered when the authentication data is invalidated by the authenticator\n    due to an external or scheduled event__. This might happen, e.g., if a token\n    expires or an event is triggered from an external authentication provider\n    that the authenticator uses. The session handles the event and will\n    invalidate itself when it is triggered.\n\n    @event sessionDataInvalidated\n    @public\n  */\n\n  /**\n    Restores the session from a session data object. __This method is invoked\n    by the session either on application startup if session data is restored\n    from the session store__ or when properties in the store change due to\n    external events (e.g. in another tab) and the new session data needs to be\n    validated for whether it constitutes an authenticated session.\n\n    __This method returns a promise. A resolving promise results in the session\n    becoming or remaining authenticated.__ Any data the promise resolves with\n    will be saved in and accessible via the session service's\n    `data.authenticated` property (see\n    {{#crossLink \"SessionService/data:property\"}}{{/crossLink}}). A rejecting\n    promise indicates that `data` does not constitute a valid session and will\n    result in the session being invalidated or remaining unauthenticated.\n\n    The `BaseAuthenticator`'s implementation always returns a rejecting\n    promise. __This method must be overridden in subclasses.__\n\n    @method restore\n    @param {Object} data The data to restore the session from\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming or remaining authenticated\n    @public\n  */\n  restore() {\n    return RSVP.reject();\n  },\n\n  /**\n    Authenticates the session with the specified `args`. These options vary\n    depending on the actual authentication mechanism the authenticator\n    implements (e.g. a set of credentials or a Facebook account id etc.). __The\n    session will invoke this method in order to authenticate itself__ (see\n    {{#crossLink \"SessionService/authenticate:method\"}}{{/crossLink}}).\n\n    __This method returns a promise. A resolving promise will result in the\n    session becoming authenticated.__ Any data the promise resolves with will\n    be saved in and accessible via the session service's `data.authenticated`\n    property (see {{#crossLink \"SessionService/data:property\"}}{{/crossLink}}).\n    A rejecting promise indicates that authentication failed and will result in\n    the session remaining unauthenticated.\n\n    The `BaseAuthenticator`'s implementation always returns a rejecting promise\n    and thus never authenticates the session. __This method must be overridden\n    in subclasses__.\n\n    @method authenticate\n    @param {Any} [...args] The arguments that the authenticator requires to authenticate the session\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming authenticated\n    @public\n  */\n  authenticate() {\n    return RSVP.reject();\n  },\n\n  /**\n    This method is invoked as a callback when the session is invalidated. While\n    the session will invalidate itself and clear all authenticated session data,\n    it might be necessary for some authenticators to perform additional tasks\n    (e.g. invalidating an access token on the server side).\n\n    __This method returns a promise. A resolving promise will result in the\n    session becoming unauthenticated.__ A rejecting promise will result in\n    invalidation being intercepted and the session remaining authenticated.\n\n    The `BaseAuthenticator`'s implementation always returns a resolving promise\n    and thus never intercepts session invalidation. __This method doesn't have\n    to be overridden in custom authenticators__ if no actions need to be\n    performed on session invalidation.\n\n    @method invalidate\n    @param {Object} data The current authenticated session data\n    @param {Array} ...args additional arguments as required by the authenticator\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session being invalidated\n    @public\n  */\n  invalidate() {\n    return RSVP.resolve();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authenticators/devise.js":"import Ember from 'ember';\nimport BaseAuthenticator from './base';\nimport fetch from 'ember-network/fetch';\n\nconst { RSVP: { Promise }, isEmpty, run, assign: emberAssign, merge, computed } = Ember;\nconst assign = emberAssign || merge;\n\nconst JSON_CONTENT_TYPE = 'application/json';\n\n/**\n  Authenticator that works with the Ruby gem\n  [devise](https://github.com/plataformatec/devise).\n\n  __As token authentication is not actually part of devise anymore, the server\n  needs to implement some customizations__ to work with this authenticator -\n  see [this gist](https://gist.github.com/josevalim/fb706b1e933ef01e4fb6).\n\n  @class DeviseAuthenticator\n  @module ember-simple-auth/authenticators/devise\n  @extends BaseAuthenticator\n  @public\n*/\nexport default BaseAuthenticator.extend({\n  /**\n    The endpoint on the server that the authentication request is sent to.\n\n    @property serverTokenEndpoint\n    @type String\n    @default '/users/sign_in'\n    @public\n  */\n  serverTokenEndpoint: '/users/sign_in',\n\n  /**\n    The devise resource name. __This will be used in the request and also be\n    expected in the server's response.__\n\n    @property resourceName\n    @type String\n    @default 'user'\n    @public\n  */\n  resourceName: 'user',\n\n  /**\n    The token attribute name. __This will be used in the request and also be\n    expected in the server's response.__\n\n    @property tokenAttributeName\n    @type String\n    @default 'token'\n    @public\n  */\n  tokenAttributeName: 'token',\n\n  /**\n    The identification attribute name. __This will be used in the request and\n    also be expected in the server's response.__\n\n    @property identificationAttributeName\n    @type String\n    @default 'email'\n    @public\n  */\n  identificationAttributeName: 'email',\n\n  /**\n    When authentication fails, the rejection callback is provided with the whole\n    Fetch API [Response](https://fetch.spec.whatwg.org/#response-class) object\n    instead of its responseJSON or responseText.\n\n    This is useful for cases when the backend provides additional context not\n    available in the response body.\n\n    @property rejectWithXhr\n    @type Boolean\n    @default false\n    @deprecated DeviseAuthenticator/rejectWithResponse:property\n    @public\n  */\n  rejectWithXhr: computed.deprecatingAlias('rejectWithResponse', {\n    id: `ember-simple-auth.authenticator.reject-with-xhr`,\n    until: '2.0.0'\n  }),\n\n  /**\n    When authentication fails, the rejection callback is provided with the whole\n    Fetch API [Response](https://fetch.spec.whatwg.org/#response-class) object\n    instead of its responseJSON or responseText.\n\n    This is useful for cases when the backend provides additional context not\n    available in the response body.\n\n    @property rejectWithResponse\n    @type Boolean\n    @default false\n    @public\n  */\n  rejectWithResponse: false,\n\n  /**\n    Restores the session from a session data object; __returns a resolving\n    promise when there are non-empty\n    {{#crossLink \"DeviseAuthenticator/tokenAttributeName:property\"}}token{{/crossLink}}\n    and\n    {{#crossLink \"DeviseAuthenticator/identificationAttributeName:property\"}}identification{{/crossLink}}\n    values in `data`__ and a rejecting promise otherwise.\n\n    @method restore\n    @param {Object} data The data to restore the session from\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming or remaining authenticated\n    @public\n  */\n  restore(data) {\n    // eslint-disable-next-line prefer-promise-reject-errors\n    return this._validate(data) ? Promise.resolve(data) : Promise.reject();\n  },\n\n  /**\n    Authenticates the session with the specified `identification` and\n    `password`; the credentials are `POST`ed to the\n    {{#crossLink \"DeviseAuthenticator/serverTokenEndpoint:property\"}}server{{/crossLink}}.\n    If the credentials are valid the server will responds with a\n    {{#crossLink \"DeviseAuthenticator/tokenAttributeName:property\"}}token{{/crossLink}}\n    and\n    {{#crossLink \"DeviseAuthenticator/identificationAttributeName:property\"}}identification{{/crossLink}}.\n    __If the credentials are valid and authentication succeeds, a promise that\n    resolves with the server's response is returned__, otherwise a promise that\n    rejects with the server error is returned.\n\n    @method authenticate\n    @param {String} identification The user's identification\n    @param {String} password The user's password\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming authenticated\n    @public\n  */\n  authenticate(identification, password) {\n    return new Promise((resolve, reject) => {\n      const useResponse = this.get('rejectWithResponse');\n      const { resourceName, identificationAttributeName, tokenAttributeName } = this.getProperties('resourceName', 'identificationAttributeName', 'tokenAttributeName');\n      const data = {};\n      data[resourceName] = { password };\n      data[resourceName][identificationAttributeName] = identification;\n\n      this.makeRequest(data).then((response) => {\n        if (response.ok) {\n          response.json().then((json) => {\n            if (this._validate(json)) {\n              const resourceName = this.get('resourceName');\n              const _json = json[resourceName] ? json[resourceName] : json;\n              run(null, resolve, _json);\n            } else {\n              run(null, reject, `Check that server response includes ${tokenAttributeName} and ${identificationAttributeName}`);\n            }\n          });\n        } else {\n          if (useResponse) {\n            run(null, reject, response);\n          } else {\n            response.json().then((json) => run(null, reject, json));\n          }\n        }\n      }).catch((error) => run(null, reject, error));\n    });\n  },\n\n  /**\n    Does nothing\n\n    @method invalidate\n    @return {Ember.RSVP.Promise} A resolving promise\n    @public\n  */\n  invalidate() {\n    return Promise.resolve();\n  },\n\n  /**\n    Makes a request to the Devise server using\n    [ember-network/fetch](https://github.com/tomdale/ember-network#fetch).\n\n    @method makeRequest\n    @param {Object} data The request data\n    @param {Object} options request options that are passed to `fetch`\n    @return {Promise} The promise returned by `fetch`\n    @protected\n  */\n  makeRequest(data, options = {}) {\n    let url = options.url || this.get('serverTokenEndpoint');\n    let requestOptions = {};\n    let body = JSON.stringify(data);\n    assign(requestOptions, {\n      body,\n      method:   'POST',\n      headers:  {\n        'accept':       JSON_CONTENT_TYPE,\n        'content-type': JSON_CONTENT_TYPE\n      }\n    });\n    assign(requestOptions, options || {});\n\n    return fetch(url, requestOptions);\n  },\n\n  _validate(data) {\n    const tokenAttributeName = this.get('tokenAttributeName');\n    const identificationAttributeName = this.get('identificationAttributeName');\n    const resourceName = this.get('resourceName');\n    const _data = data[resourceName] ? data[resourceName] : data;\n\n    return !isEmpty(_data[tokenAttributeName]) && !isEmpty(_data[identificationAttributeName]);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authenticators/oauth2-password-grant.js":"import Ember from 'ember';\nimport BaseAuthenticator from './base';\nimport fetch from 'ember-network/fetch';\n\nconst {\n  RSVP,\n  isEmpty,\n  run,\n  computed,\n  makeArray,\n  assign: emberAssign,\n  merge,\n  A,\n  testing,\n  warn,\n  keys: emberKeys\n} = Ember;\nconst assign = emberAssign || merge;\nconst keys = Object.keys || emberKeys; // Ember.keys deprecated in 1.13\n\n/**\n  Authenticator that conforms to OAuth 2\n  ([RFC 6749](http://tools.ietf.org/html/rfc6749)), specifically the _\"Resource\n  Owner Password Credentials Grant Type\"_.\n\n  This authenticator also automatically refreshes access tokens (see\n  [RFC 6749, section 6](http://tools.ietf.org/html/rfc6749#section-6)) if the\n  server supports it.\n\n  @class OAuth2PasswordGrantAuthenticator\n  @module ember-simple-auth/authenticators/oauth2-password-grant\n  @extends BaseAuthenticator\n  @public\n*/\nexport default BaseAuthenticator.extend({\n  /**\n    Triggered when the authenticator refreshed the access token (see\n    [RFC 6749, section 6](http://tools.ietf.org/html/rfc6749#section-6)).\n\n    @event sessionDataUpdated\n    @param {Object} data The updated session data\n    @public\n  */\n\n  /**\n    The client_id to be sent to the authentication server (see\n    https://tools.ietf.org/html/rfc6749#appendix-A.1). __This should only be\n    used for statistics or logging etc. as it cannot actually be trusted since\n    it could have been manipulated on the client!__\n\n    @property clientId\n    @type String\n    @default null\n    @public\n  */\n  clientId: null,\n\n  /**\n    The endpoint on the server that authentication and token refresh requests\n    are sent to.\n\n    @property serverTokenEndpoint\n    @type String\n    @default '/token'\n    @public\n  */\n  serverTokenEndpoint: '/token',\n\n  /**\n    The endpoint on the server that token revocation requests are sent to. Only\n    set this if the server actually supports token revocation. If this is\n    `null`, the authenticator will not revoke tokens on session invalidation.\n\n    __If token revocation is enabled but fails, session invalidation will be\n    intercepted and the session will remain authenticated (see\n    {{#crossLink \"OAuth2PasswordGrantAuthenticator/invalidate:method\"}}{{/crossLink}}).__\n\n    @property serverTokenRevocationEndpoint\n    @type String\n    @default null\n    @public\n  */\n  serverTokenRevocationEndpoint: null,\n\n  /**\n    Sets whether the authenticator automatically refreshes access tokens if the\n    server supports it.\n\n    @property refreshAccessTokens\n    @type Boolean\n    @default true\n    @public\n  */\n  refreshAccessTokens: true,\n\n  /**\n    The offset time in milliseconds to refresh the access token. This must\n    return a random number. This randomization is needed because in case of\n    multiple tabs, we need to prevent the tabs from sending refresh token\n    request at the same exact moment.\n\n    __When overriding this property, make sure to mark the overridden property\n    as volatile so it will actually have a different value each time it is\n    accessed.__\n\n    @property refreshAccessTokens\n    @type Integer\n    @default a random number between 5 and 10\n    @public\n  */\n  tokenRefreshOffset: computed(function() {\n    const min = 5;\n    const max = 10;\n\n    return (Math.floor(Math.random() * (max - min)) + min) * 1000;\n  }).volatile(),\n\n  _refreshTokenTimeout: null,\n\n  _clientIdHeader: computed('clientId', function() {\n    const clientId = this.get('clientId');\n\n    if (!isEmpty(clientId)) {\n      const base64ClientId = window.btoa(clientId.concat(':'));\n      return { Authorization: `Basic ${base64ClientId}` };\n    }\n  }),\n\n  /**\n    When authentication fails, the rejection callback is provided with the whole\n    Fetch API [Response](https://fetch.spec.whatwg.org/#response-class) object\n    instead of its responseJSON or responseText.\n\n    This is useful for cases when the backend provides additional context not\n    available in the response body.\n\n    @property rejectWithXhr\n    @type Boolean\n    @default false\n    @deprecated OAuth2PasswordGrantAuthenticator/rejectWithResponse:property\n    @public\n  */\n  rejectWithXhr: computed.deprecatingAlias('rejectWithResponse', {\n    id: `ember-simple-auth.authenticator.reject-with-xhr`,\n    until: '2.0.0'\n  }),\n\n  /**\n    When authentication fails, the rejection callback is provided with the whole\n    Fetch API [Response](https://fetch.spec.whatwg.org/#response-class) object\n    instead of its responseJSON or responseText.\n\n    This is useful for cases when the backend provides additional context not\n    available in the response body.\n\n    @property rejectWithResponse\n    @type Boolean\n    @default false\n    @public\n  */\n  rejectWithResponse: false,\n\n  /**\n    Restores the session from a session data object; __will return a resolving\n    promise when there is a non-empty `access_token` in the session data__ and\n    a rejecting promise otherwise.\n\n    If the server issues\n    [expiring access tokens](https://tools.ietf.org/html/rfc6749#section-5.1)\n    and there is an expired access token in the session data along with a\n    refresh token, the authenticator will try to refresh the access token and\n    return a promise that resolves with the new access token if the refresh was\n    successful. If there is no refresh token or the token refresh is not\n    successful, a rejecting promise will be returned.\n\n    @method restore\n    @param {Object} data The data to restore the session from\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming or remaining authenticated\n    @public\n  */\n  restore(data) {\n    return new RSVP.Promise((resolve, reject) => {\n      const now = (new Date()).getTime();\n      const refreshAccessTokens = this.get('refreshAccessTokens');\n      if (!isEmpty(data['expires_at']) && data['expires_at'] < now) {\n        if (refreshAccessTokens) {\n          this._refreshAccessToken(data['expires_in'], data['refresh_token']).then(resolve, reject);\n        } else {\n          reject();\n        }\n      } else {\n        if (!this._validate(data)) {\n          reject();\n        } else {\n          this._scheduleAccessTokenRefresh(data['expires_in'], data['expires_at'], data['refresh_token']);\n          resolve(data);\n        }\n      }\n    });\n  },\n\n  /**\n    Authenticates the session with the specified `identification`, `password`\n    and optional `scope`; issues a `POST` request to the\n    {{#crossLink \"OAuth2PasswordGrantAuthenticator/serverTokenEndpoint:property\"}}{{/crossLink}}\n    and receives the access token in response (see\n    http://tools.ietf.org/html/rfc6749#section-4.3).\n\n    __If the credentials are valid (and the optionally requested scope is\n    granted) and thus authentication succeeds, a promise that resolves with the\n    server's response is returned__, otherwise a promise that rejects with the\n    error as returned by the server is returned.\n\n    __If the\n    [server supports it](https://tools.ietf.org/html/rfc6749#section-5.1), this\n    method also schedules refresh requests for the access token before it\n    expires.__\n\n    @method authenticate\n    @param {String} identification The resource owner username\n    @param {String} password The resource owner password\n    @param {String|Array} scope The scope of the access request (see [RFC 6749, section 3.3](http://tools.ietf.org/html/rfc6749#section-3.3))\n    @param {Object} headers Optional headers that particular backends may require (for example sending 2FA challenge responses)\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming authenticated\n    @public\n  */\n  authenticate(identification, password, scope = [], headers = {}) {\n    return new RSVP.Promise((resolve, reject) => {\n      const data = { 'grant_type': 'password', username: identification, password };\n      const serverTokenEndpoint = this.get('serverTokenEndpoint');\n      const useResponse = this.get('rejectWithResponse');\n      const scopesString = makeArray(scope).join(' ');\n      if (!isEmpty(scopesString)) {\n        data.scope = scopesString;\n      }\n      this.makeRequest(serverTokenEndpoint, data, headers).then((response) => {\n        run(() => {\n          if (!this._validate(response)) {\n            reject('access_token is missing in server response');\n          }\n\n          const expiresAt = this._absolutizeExpirationTime(response['expires_in']);\n          this._scheduleAccessTokenRefresh(response['expires_in'], expiresAt, response['refresh_token']);\n          if (!isEmpty(expiresAt)) {\n            response = assign(response, { 'expires_at': expiresAt });\n          }\n\n          resolve(response);\n        });\n      }, (response) => {\n        run(null, reject, useResponse ? response : response.responseJSON);\n      });\n    });\n  },\n\n  /**\n    If token revocation is enabled, this will revoke the access token (and the\n    refresh token if present). If token revocation succeeds, this method\n    returns a resolving promise, otherwise it will return a rejecting promise,\n    thus intercepting session invalidation.\n\n    If token revocation is not enabled this method simply returns a resolving\n    promise.\n\n    @method invalidate\n    @param {Object} data The current authenticated session data\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session being invalidated\n    @public\n  */\n  invalidate(data) {\n    const serverTokenRevocationEndpoint = this.get('serverTokenRevocationEndpoint');\n    function success(resolve) {\n      run.cancel(this._refreshTokenTimeout);\n      delete this._refreshTokenTimeout;\n      resolve();\n    }\n    return new RSVP.Promise((resolve) => {\n      if (isEmpty(serverTokenRevocationEndpoint)) {\n        success.apply(this, [resolve]);\n      } else {\n        const requests = [];\n        A(['access_token', 'refresh_token']).forEach((tokenType) => {\n          const token = data[tokenType];\n          if (!isEmpty(token)) {\n            requests.push(this.makeRequest(serverTokenRevocationEndpoint, {\n              'token_type_hint': tokenType, token\n            }));\n          }\n        });\n        const succeed = () => {\n          success.apply(this, [resolve]);\n        };\n        RSVP.all(requests).then(succeed, succeed);\n      }\n    });\n  },\n\n  /**\n    Makes a request to the OAuth 2.0 server.\n\n    @method makeRequest\n    @param {String} url The request URL\n    @param {Object} data The request data\n    @param {Object} headers Additional headers to send in request\n    @return {Promise} A promise that resolves with the response object\n    @protected\n  */\n  makeRequest(url, data, headers = {}) {\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\n\n    const body = keys(data).map((key) => {\n      return `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}`;\n    }).join('&');\n\n    const options = {\n      body,\n      headers,\n      method: 'POST'\n    };\n\n    const clientIdHeader = this.get('_clientIdHeader');\n    if (!isEmpty(clientIdHeader)) {\n      merge(options.headers, clientIdHeader);\n    }\n    return new RSVP.Promise((resolve, reject) => {\n      fetch(url, options).then((response) => {\n        response.text().then((text) => {\n          let json = text ? JSON.parse(text) : {};\n          if (!response.ok) {\n            response.responseJSON = json;\n            reject(response);\n          } else {\n            resolve(json);\n          }\n        });\n      }).catch(reject);\n    });\n  },\n\n  _scheduleAccessTokenRefresh(expiresIn, expiresAt, refreshToken) {\n    const refreshAccessTokens = this.get('refreshAccessTokens');\n    if (refreshAccessTokens) {\n      const now = (new Date()).getTime();\n      if (isEmpty(expiresAt) && !isEmpty(expiresIn)) {\n        expiresAt = new Date(now + expiresIn * 1000).getTime();\n      }\n      const offset = this.get('tokenRefreshOffset');\n      if (!isEmpty(refreshToken) && !isEmpty(expiresAt) && expiresAt > now - offset) {\n        run.cancel(this._refreshTokenTimeout);\n        delete this._refreshTokenTimeout;\n        if (!testing) {\n          this._refreshTokenTimeout = run.later(this, this._refreshAccessToken, expiresIn, refreshToken, expiresAt - now - offset);\n        }\n      }\n    }\n  },\n\n  _refreshAccessToken(expiresIn, refreshToken) {\n    const data = { 'grant_type': 'refresh_token', 'refresh_token': refreshToken };\n    const serverTokenEndpoint = this.get('serverTokenEndpoint');\n    return new RSVP.Promise((resolve, reject) => {\n      this.makeRequest(serverTokenEndpoint, data).then((response) => {\n        run(() => {\n          expiresIn = response['expires_in'] || expiresIn;\n          refreshToken = response['refresh_token'] || refreshToken;\n          const expiresAt = this._absolutizeExpirationTime(expiresIn);\n          const data = assign(response, { 'expires_in': expiresIn, 'expires_at': expiresAt, 'refresh_token': refreshToken });\n          this._scheduleAccessTokenRefresh(expiresIn, null, refreshToken);\n          this.trigger('sessionDataUpdated', data);\n          resolve(data);\n        });\n      }, (response) => {\n        warn(`Access token could not be refreshed - server responded with ${response.responseJSON}.`, false, { id: 'ember-simple-auth.failedOAuth2TokenRefresh' });\n        reject();\n      });\n    });\n  },\n\n  _absolutizeExpirationTime(expiresIn) {\n    if (!isEmpty(expiresIn)) {\n      return new Date((new Date().getTime()) + expiresIn * 1000).getTime();\n    }\n  },\n\n  _validate(data) {\n    return !isEmpty(data['access_token']);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authenticators/torii.js":"import Ember from 'ember';\nimport BaseAuthenticator from './base';\n\nconst { RSVP, isEmpty, assert, isPresent } = Ember;\n\n/**\n  Authenticator that wraps the\n  [Torii library](https://github.com/Vestorly/torii) and thus allows to connect\n  any external authentication provider that torii defines a provider for.\n\n  In order to use this authenticator, __the application needs to have the\n  [torii addon](https://github.com/Vestorly/torii) installed and must inject\n  the torii service into the authenticator__:\n\n  ```js\n  // app/authenticators/torii.js\n  import ToriiAuthenticator from 'ember-simple-auth/authenticators/torii';\n\n  export default ToriiAuthenticator.extend({\n    torii: Ember.inject.service()\n  });\n  ```\n\n  @class ToriiAuthenticator\n  @module ember-simple-auth/authenticators/torii\n  @extends BaseAuthenticator\n  @public\n*/\nexport default BaseAuthenticator.extend({\n  _provider: null,\n\n  /**\n    Restores the session by calling the torii provider's `fetch` method.\n\n    __Many torii providers do not implement the `fetch` method__. If the\n    provider in use does not implement the method simply add it as follows:\n\n    ```js\n    // app/torii-providers/facebook.js\n    import FacebookOauth2Provider from 'torii/providers/facebook-oauth2';\n\n    export default FacebookOauth2Provider.extend({\n      fetch(data) {\n        return data;\n      }\n    });\n    ```\n\n    @method restore\n    @param {Object} data The data to restore the session from\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming or remaining authenticated\n    @public\n  */\n  restore(data) {\n    this._assertToriiIsPresent();\n\n    data = data || {};\n    if (!isEmpty(data.provider)) {\n      const { provider } = data;\n\n      return this.get('torii').fetch(data.provider, data).then((data) => {\n        this._authenticateWithProvider(provider, data);\n        return data;\n      }, () => delete this._provider);\n    } else {\n      delete this._provider;\n      return RSVP.reject();\n    }\n  },\n\n  /**\n    Authenticates the session by opening the specified torii provider. For more\n    documentation on torii and its providers abstraction, see the\n    [project's README](https://github.com/Vestorly/torii#readme), specifically\n    the\n    [section on providers](https://github.com/Vestorly/torii#configuring-a-torii-provider).\n\n    @method authenticate\n    @param {String} provider The torii provider to authenticate the session with\n    @param {Object} options The options to pass to the torii provider\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session becoming authenticated\n    @public\n  */\n  authenticate(provider, options) {\n    this._assertToriiIsPresent();\n\n    return this.get('torii').open(provider, options || {}).then((data) => {\n      this._authenticateWithProvider(provider, data);\n      return data;\n    });\n  },\n\n  /**\n    Closes the torii provider. If the provider is successfully closed, this\n    method returns a resolving promise, otherwise it will return a rejecting\n    promise, thus intercepting session invalidation.\n\n    @method invalidate\n    @return {Ember.RSVP.Promise} A promise that when it resolves results in the session being invalidated\n    @public\n  */\n  invalidate(data) {\n    return this.get('torii').close(this._provider, data).then(() => {\n      delete this._provider;\n    });\n  },\n\n  _authenticateWithProvider(provider, data) {\n    data.provider = provider;\n    this._provider = data.provider;\n  },\n\n  _assertToriiIsPresent() {\n    const torii = this.get('torii');\n    assert('You are trying to use the torii authenticator but torii is not available. Inject torii into the authenticator with \"torii: Ember.inject.service()\".', isPresent(torii));\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authorizers/base.js":"import Ember from 'ember';\n\nconst { Object: EmberObject } = Ember;\n\n/**\n  The base class for all authorizers. __This serves as a starting point for\n  implementing custom authorizers and must not be used directly.__\n\n  Authorizers use the session data acquired by an authenticator when\n  authenticating the session to construct authorization data that can, e.g., be\n  injected into outgoing network requests. Depending on the authorization\n  mechanism the authorizer implements, that authorization data might be an HTTP\n  header, query string parameters, a cookie, etc.\n\n  __The authorizer has to fit the authenticator__ (see\n  {{#crossLink \"BaseAuthenticator\"}}{{/crossLink}})\n  as it can only use data that the authenticator acquires when authenticating\n  the session.\n\n  @class BaseAuthorizer\n  @module ember-simple-auth/authorizers/base\n  @extends Ember.Object\n  @public\n*/\nexport default EmberObject.extend({\n  /**\n    Authorizes a block of code. This method will be invoked by the session\n    service's {{#crossLink \"SessionService/authorize:method\"}}{{/crossLink}}\n    method which will pass the current authenticated session data (see\n    {{#crossLink \"SessionService/data:property\"}}{{/crossLink}}) and a block.\n    Depending on the mechanism it implements, the authorizer transforms the\n    session data into authorization data and invokes the block with that data.\n\n    `BaseAuthorizer`'s implementation does nothing. __This method must be\n    overridden in custom authorizers.__\n\n    @method authorize\n    @param {Object} data The current authenticated session data\n    @param {Function} block The callback to call with the authorization data\n    @public\n  */\n  authorize() {}\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authorizers/devise.js":"import Ember from 'ember';\nimport BaseAuthorizer from './base';\n\nconst { isEmpty } = Ember;\n\n/**\n  Authorizer that works with the Ruby gem\n  [devise](https://github.com/plataformatec/devise); includes the user's token\n  and identification from the session data in the `Authorization` HTTP header,\n  e.g.,\n\n  ```\n  Authorization: token=\"234rtgjneroigne4\" email=\"user@domain.tld\"\n  ```\n\n  __As token authentication is not actually part of devise anymore, the server\n  needs to implement some customizations__ to work with this authenticator -\n  see [this gist](https://gist.github.com/josevalim/fb706b1e933ef01e4fb6).\n\n  @class DeviseAuthorizer\n  @module ember-simple-auth/authorizers/devise\n  @extends BaseAuthorizer\n  @public\n*/\nexport default BaseAuthorizer.extend({\n  /**\n    The token attribute name.\n\n    @property tokenAttributeName\n    @type String\n    @default 'token'\n    @public\n  */\n  tokenAttributeName: 'token',\n\n  /**\n    The identification attribute name.\n\n    @property identificationAttributeName\n    @type String\n    @default 'email'\n    @public\n  */\n  identificationAttributeName: 'email',\n\n  /**\n    Includes the user's token (see\n    {{#crossLink \"DeviseAuthenticator/tokenAttributeName:property\"}}{{/crossLink}})\n    and identification (see\n    {{#crossLink \"DeviseAuthenticator/identificationAttributeName:property\"}}{{/crossLink}})\n    in the `Authorization` header.\n\n    @method authorize\n    @param {Object} data The data that the session currently holds\n    @param {Function} block(headerName,headerContent) The callback to call with the authorization data; will receive the header name and header content as arguments.\n    @public\n  */\n  authorize(data, block) {\n    const { tokenAttributeName, identificationAttributeName } = this.getProperties('tokenAttributeName', 'identificationAttributeName');\n    const userToken = data[tokenAttributeName];\n    const userIdentification = data[identificationAttributeName];\n\n    if (!isEmpty(userToken) && !isEmpty(userIdentification)) {\n      const authData = `${tokenAttributeName}=\"${userToken}\", ${identificationAttributeName}=\"${userIdentification}\"`;\n      block('Authorization', `Token ${authData}`);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/authorizers/oauth2-bearer.js":"import Ember from 'ember';\nimport Base from './base';\n\nconst { isEmpty } = Ember;\n\n/**\n  Authorizer that conforms to OAuth 2\n  ([RFC 6749](http://tools.ietf.org/html/rfc6749)); includes the access token\n  from the session data as a bearer token\n  ([RFC 6750](http://tools.ietf.org/html/rfc6750)) in the `Authorization`\n  header, e.g.:\n\n  ```\n  Authorization: Bearer 234rtgjneroigne4\n  ```\n\n  @class OAuth2BearerAuthorizer\n  @module ember-simple-auth/authorizers/oauth2-bearer\n  @extends BaseAuthorizer\n  @public\n*/\nexport default Base.extend({\n  /**\n    Includes the access token from the session data into the `Authorization`\n    header as a Bearer token, e.g.:\n\n    ```\n    Authorization: Bearer 234rtgjneroigne4\n    ```\n\n    @method authorize\n    @param {Object} data The data that the session currently holds\n    @param {Function} block(headerName,headerContent) The callback to call with the authorization data; will receive the header name and header content as arguments\n    @public\n  */\n  authorize(data, block) {\n    const accessToken = data['access_token'];\n\n    if (!isEmpty(accessToken)) {\n      block('Authorization', `Bearer ${accessToken}`);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/initializers/setup-session.js":"import Ember from 'ember';\nimport InternalSession from '../internal-session';\nimport Ephemeral from '../session-stores/ephemeral';\nimport inject from '../utils/inject';\n\nexport default function setupSession(registry) {\n  registry.register('session:main', InternalSession);\n\n  let store = 'session-store:application';\n  if (Ember.testing) {\n    store = 'session-store:test';\n    registry.register(store, Ephemeral);\n  }\n\n  inject(registry, 'session:main', 'store', store);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/initializers/setup-session-service.js":"import inject from '../utils/inject';\n\nexport default function setupSessionStore(registry) {\n  inject(registry, 'service:session', 'session', 'session:main');\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/instance-initializers/setup-session-restoration.js":"import lookup from '../utils/lookup';\n\nexport default function setupSessionRestoration(instance) {\n  const applicationRoute = lookup(instance, 'route:application');\n  const session = lookup(instance, 'session:main');\n  const originalBeforeModel = applicationRoute.beforeModel;\n  const applyOriginalBeforeModel = function() {\n    return originalBeforeModel.apply(applicationRoute, arguments);\n  };\n  applicationRoute.reopen({\n    beforeModel() {\n      return session.restore().then(\n        () => applyOriginalBeforeModel(...arguments),\n        () => applyOriginalBeforeModel(...arguments)\n      );\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/mixins/application-route-mixin.js":"import Ember from 'ember';\nimport Configuration from './../configuration';\n\nconst { inject, Mixin, A, run: { bind }, testing, computed, getOwner } = Ember;\n\n/**\n  The mixin for the application route, __defining methods that are called when\n  the session is successfully authenticated (see\n  {{#crossLink \"SessionService/authenticationSucceeded:event\"}}{{/crossLink}})\n  or invalidated__ (see\n  {{#crossLink \"SessionService/invalidationSucceeded:event\"}}{{/crossLink}}).\n\n  __Using this mixin is optional.__ The session events can also be handled\n  manually, e.g. in an instance initializer:\n\n  ```js\n  // app/instance-initializers/session-events.js\n  export function initialize(instance) {\n    const applicationRoute = instance.container.lookup('route:application');\n    const session          = instance.container.lookup('service:session');\n    session.on('authenticationSucceeded', function() {\n      applicationRoute.transitionTo('index');\n    });\n    session.on('invalidationSucceeded', function() {\n      applicationRoute.transitionTo('bye');\n    });\n  };\n\n  export default {\n    initialize,\n    name:  'session-events',\n    after: 'ember-simple-auth'\n  };\n  ```\n\n  __When using the `ApplicationRouteMixin` you need to specify\n  `needs: ['service:session']` in the application route's unit test.__\n\n  @class ApplicationRouteMixin\n  @module ember-simple-auth/mixins/application-route-mixin\n  @extends Ember.Mixin\n  @public\n*/\nexport default Mixin.create({\n  /**\n    The session service.\n\n    @property session\n    @readOnly\n    @type SessionService\n    @public\n  */\n  session: inject.service('session'),\n\n  _isFastBoot: computed(function() {\n    const fastboot = getOwner(this).lookup('service:fastboot');\n\n    return fastboot ? fastboot.get('isFastBoot') : false;\n  }),\n\n  /**\n    The route to transition to after successful authentication.\n\n    @property routeAfterAuthentication\n    @type String\n    @default 'index'\n    @public\n  */\n  routeAfterAuthentication: computed(function() {\n    return Configuration.routeAfterAuthentication;\n  }),\n\n  init() {\n    this._super(...arguments);\n    this._subscribeToSessionEvents();\n  },\n\n  _subscribeToSessionEvents() {\n    A([\n      ['authenticationSucceeded', 'sessionAuthenticated'],\n      ['invalidationSucceeded', 'sessionInvalidated']\n    ]).forEach(([event, method]) => {\n      this.get('session').on(event, bind(this, () => {\n        this[method](...arguments);\n      }));\n    });\n  },\n\n  /**\n    This method handles the session's\n    {{#crossLink \"SessionService/authenticationSucceeded:event\"}}{{/crossLink}}\n    event. If there is a transition that was previously intercepted by the\n    {{#crossLink \"AuthenticatedRouteMixin/beforeModel:method\"}}\n    AuthenticatedRouteMixin's `beforeModel` method{{/crossLink}} it will retry\n    it. If there is no such transition, the `ember_simple_auth-redirectTarget`\n    cookie will be checked for a url that represents an attemptedTransition\n    that was aborted in Fastboot mode, otherwise this action transitions to the\n    {{#crossLink \"Configuration/routeAfterAuthentication:property\"}}{{/crossLink}}.\n\n\n    @method sessionAuthenticated\n    @public\n  */\n  sessionAuthenticated() {\n    const attemptedTransition = this.get('session.attemptedTransition');\n    const cookies = getOwner(this).lookup('service:cookies');\n    const redirectTarget = cookies.read('ember_simple_auth-redirectTarget');\n\n    if (attemptedTransition) {\n      attemptedTransition.retry();\n      this.set('session.attemptedTransition', null);\n    } else if (redirectTarget) {\n      this.transitionTo(redirectTarget);\n      cookies.clear('ember_simple_auth-redirectTarget');\n    } else {\n      this.transitionTo(this.get('routeAfterAuthentication'));\n    }\n  },\n\n  /**\n    This method handles the session's\n    {{#crossLink \"SessionService/invalidationSucceeded:event\"}}{{/crossLink}}\n    event. __It reloads the Ember.js application__ by redirecting the browser\n    to the application's root URL so that all in-memory data (such as Ember\n    Data stores etc.) gets cleared.\n\n    If the Ember.js application will be used in an environment where the users\n    don't have direct access to any data stored on the client (e.g.\n    [cordova](http://cordova.apache.org)) this action can be overridden to e.g.\n    simply transition to the index route.\n\n    @method sessionInvalidated\n    @public\n  */\n  sessionInvalidated() {\n    if (!testing) {\n      if (this.get('_isFastBoot')) {\n        this.transitionTo(Configuration.baseURL);\n      } else {\n        window.location.replace(Configuration.baseURL);\n      }\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/mixins/authenticated-route-mixin.js":"import Ember from 'ember';\nimport Configuration from './../configuration';\n\nconst { inject: { service }, Mixin, assert, computed, getOwner } = Ember;\n\n/**\n  __This mixin is used to make routes accessible only if the session is\n  authenticated.__ It defines a `beforeModel` method that aborts the current\n  transition and instead transitions to the\n  {{#crossLink \"Configuration/authenticationRoute:property\"}}{{/crossLink}} if\n  the session is not authenticated.\n\n  ```js\n  // app/routes/protected.js\n  import AuthenticatedRouteMixin from 'ember-simple-auth/mixins/authenticated-route-mixin';\n\n  export default Ember.Route.extend(AuthenticatedRouteMixin);\n  ```\n\n  @class AuthenticatedRouteMixin\n  @module ember-simple-auth/mixins/authenticated-route-mixin\n  @extends Ember.Mixin\n  @public\n*/\nexport default Mixin.create({\n  /**\n    The session service.\n\n    @property session\n    @readOnly\n    @type SessionService\n    @public\n  */\n  session: service('session'),\n\n  _isFastBoot: computed(function() {\n    const fastboot = getOwner(this).lookup('service:fastboot');\n\n    return fastboot ? fastboot.get('isFastBoot') : false;\n  }),\n\n  /**\n    The route to transition to for authentication. The\n    {{#crossLink \"AuthenticatedRouteMixin\"}}{{/crossLink}} will transition to\n    this route when a route that implements the mixin is accessed when the\n    route is not authenticated.\n\n    @property authenticationRoute\n    @type String\n    @default 'login'\n    @public\n  */\n  authenticationRoute: computed(function() {\n    return Configuration.authenticationRoute;\n  }),\n\n  /**\n    Checks whether the session is authenticated and if it is not aborts the\n    current transition and instead transitions to the\n    {{#crossLink \"Configuration/authenticationRoute:property\"}}{{/crossLink}}.\n    If the current transition is aborted, this method will save it in the\n    session service's\n    {{#crossLink \"SessionService/attemptedTransition:property\"}}{{/crossLink}}\n    property so that  it can be retried after the session is authenticated\n    (see\n    {{#crossLink \"ApplicationRouteMixin/sessionAuthenticated:method\"}}{{/crossLink}}).\n    If the transition is aborted in Fastboot mode, the transition's target\n    URL will be saved in a `ember_simple_auth-redirectTarget` cookie for use by\n    the browser after authentication is complete.\n\n    __If `beforeModel` is overridden in a route that uses this mixin, the route's\n   implementation must call `this._super(...arguments)`__ so that the mixin's\n   `beforeModel` method is actually executed.\n\n    @method beforeModel\n    @param {Transition} transition The transition that lead to this route\n    @public\n  */\n  beforeModel(transition) {\n    if (!this.get('session.isAuthenticated')) {\n      if (this.get('_isFastBoot')) {\n        const fastboot = getOwner(this).lookup('service:fastboot');\n        const cookies = getOwner(this).lookup('service:cookies');\n\n        cookies.write('ember_simple_auth-redirectTarget', transition.intent.url, {\n          path: '/',\n          secure: fastboot.get('request.protocol') === 'https'\n        });\n      } else {\n        this.set('session.attemptedTransition', transition);\n      }\n\n      this.triggerAuthentication();\n    } else {\n      return this._super(...arguments);\n    }\n  },\n\n  /**\n    Triggers authentication; by default this method transitions to the\n    `authenticationRoute`. In case the application uses an authentication\n    mechanism that does not use an authentication route, this method can be\n    overridden.\n\n    @method triggerAuthentication\n    @protected\n  */\n  triggerAuthentication() {\n    let authenticationRoute = this.get('authenticationRoute');\n    assert('The route configured as Configuration.authenticationRoute cannot implement the AuthenticatedRouteMixin mixin as that leads to an infinite transitioning loop!', this.get('routeName') !== authenticationRoute);\n\n    this.transitionTo(authenticationRoute);\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/mixins/data-adapter-mixin.js":"import Ember from 'ember';\n\nconst { inject: { service }, Mixin, assert, isPresent } = Ember;\n\n/**\n  __This mixin can be used to make Ember Data adapters authorize all outgoing\n  API requests by injecting a header.__ It works with all authorizers that call\n  the authorization callback (see\n  {{#crossLink \"BaseAuthorizer/authorize:method\"}}{{/crossLink}}) with header\n  name and header content arguments.\n\n  __The `DataAdapterMixin` will also invalidate the session whenever it\n  receives a 401 response for an API request.__\n\n  ```js\n  // app/adapters/application.js\n  import DS from 'ember-data';\n  import DataAdapterMixin from 'ember-simple-auth/mixins/data-adapter-mixin';\n\n  export default DS.JSONAPIAdapter.extend(DataAdapterMixin, {\n    authorizer: 'authorizer:application'\n  });\n  ```\n\n  __The `DataAdapterMixin` requires Ember Data 1.13 or later.__\n\n  @class DataAdapterMixin\n  @module ember-simple-auth/mixins/data-adapter-mixin\n  @extends Ember.Mixin\n  @public\n*/\n\nexport default Mixin.create({\n  /**\n    The session service.\n\n    @property session\n    @readOnly\n    @type SessionService\n    @public\n  */\n  session: service('session'),\n\n  /**\n    The authorizer that is used to authorize API requests. The authorizer has\n    to call the authorization callback (see\n    {{#crossLink \"BaseAuthorizer/authorize:method\"}}{{/crossLink}}) with header\n    name and header content arguments. __This property must be overridden in\n    adapters using this mixin.__\n\n    @property authorizer\n    @type String\n    @default null\n    @public\n  */\n  authorizer: null,\n\n  /**\n    Defines a `beforeSend` hook (see http://api.jquery.com/jQuery.ajax/) that\n    injects a request header containing the authorization data as constructed\n    by the {{#crossLink \"DataAdapterMixin/authorizer:property\"}}{{/crossLink}}\n    (see\n    {{#crossLink \"SessionService/authorize:method\"}}{{/crossLink}}). The\n    specific header name and contents depend on the actual authorizer that is\n    used.\n\n    This method applies for Ember Data 2.6 and older. See `headersForRequest`\n    for newer versions of Ember Data.\n\n    @method ajaxOptions\n    @protected\n  */\n  ajaxOptions() {\n    const authorizer = this.get('authorizer');\n    assert(\"You're using the DataAdapterMixin without specifying an authorizer. Please add `authorizer: 'authorizer:application'` to your adapter.\", isPresent(authorizer));\n\n    let hash = this._super(...arguments);\n    let { beforeSend } = hash;\n\n    hash.beforeSend = (xhr) => {\n      this.get('session').authorize(authorizer, (headerName, headerValue) => {\n        xhr.setRequestHeader(headerName, headerValue);\n      });\n      if (beforeSend) {\n        beforeSend(xhr);\n      }\n    };\n    return hash;\n  },\n\n  /**\n    Adds request headers containing the authorization data as constructed\n    by the {{#crossLink \"DataAdapterMixin/authorizer:property\"}}{{/crossLink}}.\n\n    This method will only be called in Ember Data 2.7 or greater. Older versions\n    will rely on `ajaxOptions` for request header injection.\n\n    @method headersForRequest\n    @protected\n   */\n  headersForRequest() {\n    const authorizer = this.get('authorizer');\n    assert(\"You're using the DataAdapterMixin without specifying an authorizer. Please add `authorizer: 'authorizer:application'` to your adapter.\", isPresent(authorizer));\n\n    let headers = this._super(...arguments);\n    headers = Object(headers);\n    this.get('session').authorize(authorizer, (headerName, headerValue) => {\n      headers[headerName] = headerValue;\n    });\n    return headers;\n  },\n\n  /**\n    This method is called for every response that the adapter receives from the\n    API. If the response has a 401 status code it invalidates the session (see\n    {{#crossLink \"SessionService/invalidate:method\"}}{{/crossLink}}).\n\n    @method handleResponse\n    @param {Number} status The response status as received from the API\n    @protected\n  */\n  handleResponse(status) {\n    if (status === 401 && this.get('session.isAuthenticated')) {\n      this.get('session').invalidate();\n    }\n    return this._super(...arguments);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/mixins/unauthenticated-route-mixin.js":"import Ember from 'ember';\nimport Configuration from './../configuration';\n\nconst { inject: { service }, Mixin, assert, computed, getOwner } = Ember;\n\n/**\n  __This mixin is used to make routes accessible only if the session is\n  not authenticated__ (e.g., login and registration routes). It defines a\n  `beforeModel` method that aborts the current transition and instead\n  transitions to the\n  {{#crossLink \"Configuration/routeIfAlreadyAuthenticated:property\"}}{{/crossLink}}\n  if the session is authenticated.\n\n  ```js\n  // app/routes/login.js\n  import UnauthenticatedRouteMixin from 'ember-simple-auth/mixins/unauthenticated-route-mixin';\n\n  export default Ember.Route.extend(UnauthenticatedRouteMixin);\n  ```\n\n  @class UnauthenticatedRouteMixin\n  @module ember-simple-auth/mixins/unauthenticated-route-mixin\n  @extends Ember.Mixin\n  @public\n*/\nexport default Mixin.create({\n  /**\n    The session service.\n\n    @property session\n    @readOnly\n    @type SessionService\n    @public\n  */\n  session: service('session'),\n\n  _isFastBoot: computed(function() {\n    const fastboot = getOwner(this).lookup('service:fastboot');\n\n    return fastboot ? fastboot.get('isFastBoot') : false;\n  }),\n\n  /**\n    The route to transition to if a route that implements the\n    {{#crossLink \"UnauthenticatedRouteMixin\"}}{{/crossLink}} is accessed when\n    the session is authenticated.\n\n    @property routeIfAlreadyAuthenticated\n    @type String\n    @default 'index'\n    @public\n  */\n  routeIfAlreadyAuthenticated: computed(function() {\n    return Configuration.routeIfAlreadyAuthenticated;\n  }),\n\n  /**\n    Checks whether the session is authenticated and if it is aborts the current\n    transition and instead transitions to the\n    {{#crossLink \"Configuration/routeIfAlreadyAuthenticated:property\"}}{{/crossLink}}.\n\n    __If `beforeModel` is overridden in a route that uses this mixin, the route's\n   implementation must call `this._super(...arguments)`__ so that the mixin's\n   `beforeModel` method is actually executed.\n\n    @method beforeModel\n    @param {Transition} transition The transition that lead to this route\n    @public\n  */\n  beforeModel() {\n    if (this.get('session').get('isAuthenticated')) {\n      let routeIfAlreadyAuthenticated = this.get('routeIfAlreadyAuthenticated');\n      assert('The route configured as Configuration.routeIfAlreadyAuthenticated cannot implement the UnauthenticatedRouteMixin mixin as that leads to an infinite transitioning loop!', this.get('routeName') !== routeIfAlreadyAuthenticated);\n\n      this.transitionTo(routeIfAlreadyAuthenticated);\n    } else {\n      return this._super(...arguments);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/services/session.js":"import Ember from 'ember';\n\nconst SESSION_DATA_KEY_PREFIX = /^data\\./;\n\nconst { computed, A, Service, Evented, getOwner, isNone, assert } = Ember;\n\n/**\n  __The session service provides access to the current session as well as\n  methods to authenticate it, invalidate it, etc.__ It is the main interface for\n  the application to Ember Simple Auth's functionality. It can be injected via\n\n  ```js\n  // app/components/login-form.js\n  import Ember from 'ember';\n\n  export default Ember.Component.extend({\n    session: Ember.inject.service('session')\n  });\n  ```\n\n  @class SessionService\n  @module ember-simple-auth/services/session\n  @extends Ember.Service\n  @uses Ember.Evented\n  @public\n*/\nexport default Service.extend(Evented, {\n  /**\n    Triggered whenever the session is successfully authenticated. This happens\n    when the session gets authenticated via\n    {{#crossLink \"SessionService/authenticate:method\"}}{{/crossLink}} but also\n    when the session is authenticated in another tab or window of the same\n    application and the session state gets synchronized across tabs or windows\n    via the store (see\n    {{#crossLink \"BaseStore/sessionDataUpdated:event\"}}{{/crossLink}}).\n\n    When using the {{#crossLink \"ApplicationRouteMixin\"}}{{/crossLink}} this\n    event will automatically get handled (see\n    {{#crossLink \"ApplicationRouteMixin/sessionAuthenticated:method\"}}{{/crossLink}}).\n\n    @event authenticationSucceeded\n    @public\n  */\n\n  /**\n    Triggered whenever the session is successfully invalidated. This happens\n    when the session gets invalidated via\n    {{#crossLink \"SessionService/invalidate:method\"}}{{/crossLink}} but also\n    when the session is invalidated in another tab or window of the same\n    application and the session state gets synchronized across tabs or windows\n    via the store (see\n    {{#crossLink \"BaseStore/sessionDataUpdated:event\"}}{{/crossLink}}).\n\n    When using the {{#crossLink \"ApplicationRouteMixin\"}}{{/crossLink}} this\n    event will automatically get handled (see\n    {{#crossLink \"ApplicationRouteMixin/sessionInvalidated:method\"}}{{/crossLink}}).\n\n    @event invalidationSucceeded\n    @public\n  */\n\n  /**\n    Returns whether the session is currently authenticated.\n\n    @property isAuthenticated\n    @type Boolean\n    @readOnly\n    @default false\n    @public\n  */\n  isAuthenticated: computed.oneWay('session.isAuthenticated'),\n\n  /**\n    The current session data as a plain object. The\n    `authenticated` key holds the session data that the authenticator resolved\n    with when the session was authenticated (see\n    {{#crossLink \"BaseAuthenticator/authenticate:method\"}}{{/crossLink}}) and\n    that will be cleared when the session is invalidated. This data cannot be\n    written. All other session data is writable and will not be cleared when\n    the session is invalidated.\n\n    @property data\n    @type Object\n    @readOnly\n    @default { authenticated: {} }\n    @public\n  */\n  data: computed.oneWay('session.content'),\n\n  /**\n    The session store.\n\n    @property store\n    @type BaseStore\n    @readOnly\n    @default null\n    @public\n  */\n  store: computed.oneWay('session.store'),\n\n  /**\n    A previously attempted but intercepted transition (e.g. by the\n    {{#crossLink \"AuthenticatedRouteMixin\"}}{{/crossLink}}). If an attempted\n    transition is present, the\n    {{#crossLink \"ApplicationRouteMixin\"}}{{/crossLink}} will retry it when the\n    session becomes authenticated (see\n    {{#crossLink \"ApplicationRouteMixin/sessionAuthenticated:method\"}}{{/crossLink}}).\n\n    @property attemptedTransition\n    @type Transition\n    @default null\n    @public\n  */\n  attemptedTransition: computed.alias('session.attemptedTransition'),\n\n  init() {\n    this._super(...arguments);\n    this._forwardSessionEvents();\n  },\n\n  set(key, value) {\n    const setsSessionData = SESSION_DATA_KEY_PREFIX.test(key);\n    if (setsSessionData) {\n      const sessionDataKey = `session.${key.replace(SESSION_DATA_KEY_PREFIX, '')}`;\n      return this._super(sessionDataKey, value);\n    } else {\n      return this._super(...arguments);\n    }\n  },\n\n  _forwardSessionEvents() {\n    A([\n      'authenticationSucceeded',\n      'invalidationSucceeded'\n    ]).forEach((event) => {\n      const session = this.get('session');\n      // the internal session won't be available in route unit tests\n      if (session) {\n        session.on(event, () => {\n          this.trigger(event, ...arguments);\n        });\n      }\n    });\n  },\n\n  /**\n    __Authenticates the session with an `authenticator`__ and appropriate\n    arguments. The authenticator implements the actual steps necessary to\n    authenticate the session (see\n    {{#crossLink \"BaseAuthenticator/authenticate:method\"}}{{/crossLink}}) and\n    returns a promise after doing so. The session handles the returned promise\n    and when it resolves becomes authenticated, otherwise remains\n    unauthenticated. All data the authenticator resolves with will be\n    accessible via the\n    {{#crossLink \"SessionService/data:property\"}}session data's{{/crossLink}}\n    `authenticated` property.\n\n    __This method returns a promise. A resolving promise indicates that the\n    session was successfully authenticated__ while a rejecting promise\n    indicates that authentication failed and the session remains\n    unauthenticated. The promise does not resolve with a value; instead, the\n    data returned from the authenticator is available via the\n    {{#crossLink \"SessionService/data:property\"}}{{/crossLink}} property.\n\n    When authentication succeeds this will trigger the\n    {{#crossLink \"SessionService/authenticationSucceeded:event\"}}{{/crossLink}}\n    event.\n\n    @method authenticate\n    @param {String} authenticator The authenticator to use to authenticate the session\n    @param {Any} [...args] The arguments to pass to the authenticator; depending on the type of authenticator these might be a set of credentials, a Facebook OAuth Token, etc.\n    @return {Ember.RSVP.Promise} A promise that resolves when the session was authenticated successfully and rejects otherwise\n    @public\n  */\n  authenticate() {\n    const session = this.get('session');\n\n    return session.authenticate(...arguments);\n  },\n\n  /**\n    __Invalidates the session with the authenticator it is currently\n    authenticated with__ (see\n    {{#crossLink \"SessionService/authenticate:method\"}}{{/crossLink}}). This\n    invokes the authenticator's\n    {{#crossLink \"BaseAuthenticator/invalidate:method\"}}{{/crossLink}} method\n    and handles the returned promise accordingly.\n\n    This method returns a promise. A resolving promise indicates that the\n    session was successfully invalidated while a rejecting promise indicates\n    that invalidation failed and the session remains authenticated. Once the\n    session is successfully invalidated it clears all of its authenticated data\n    (see {{#crossLink \"SessionService/data:property\"}}{{/crossLink}}).\n\n    When invalidation succeeds this will trigger the\n    {{#crossLink \"SessionService/invalidationSucceeded:event\"}}{{/crossLink}}\n    event.\n\n    @method invalidate\n    @param {Array} ...args arguments that will be passed to the authenticator\n    @return {Ember.RSVP.Promise} A promise that resolves when the session was invalidated successfully and rejects otherwise\n    @public\n  */\n  invalidate() {\n    const session = this.get('session');\n\n    return session.invalidate(...arguments);\n  },\n\n  /**\n    Authorizes a block of code with an authorizer (see\n    {{#crossLink \"BaseAuthorizer/authorize:method\"}}{{/crossLink}}) if the\n    session is authenticated. If the session is not currently authenticated\n    this method does nothing.\n\n    ```js\n    this.get('session').authorize('authorizer:oauth2-bearer', (headerName, headerValue) => {\n      xhr.setRequestHeader(headerName, headerValue);\n    });\n    ```\n\n    @method authorize\n    @param {String} authorizer The authorizer to authorize the block with\n    @param {Function} block The block of code to call with the authorization data generated by the authorizer\n    @public\n  */\n  authorize(authorizerFactory, block) {\n    if (this.get('isAuthenticated')) {\n      const authorizer = getOwner(this).lookup(authorizerFactory);\n      assert(`No authorizer for factory ${authorizerFactory} could be found!`, !isNone(authorizer));\n      const sessionData = this.get('data.authenticated');\n      authorizer.authorize(sessionData, block);\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/session-stores/adaptive.js":"/* global localStorage */\nimport Ember from 'ember';\nimport Base from 'ember-simple-auth/session-stores/base';\nimport LocalStorage from 'ember-simple-auth/session-stores/local-storage';\nimport Cookie from 'ember-simple-auth/session-stores/cookie';\n\nconst { computed, inject: { service }, getOwner } = Ember;\n\nconst LOCAL_STORAGE_TEST_KEY = '_ember_simple_auth_test_key';\n\nconst proxyToInternalStore = function() {\n  return computed({\n    get(key) {\n      return this.get(`_${key}`);\n    },\n    set(key, value) {\n      this.set(`_${key}`, value);\n      let _store = this.get('_store');\n      if (_store) {\n        _store.set(key, value);\n      }\n      return value;\n    }\n  });\n};\n\n/**\n  Session store that persists data in the browser's `localStorage` (see\n  {{#crossLink \"LocalStorageStore\"}}{{/crossLink}}) if that is available or in\n  a cookie (see {{#crossLink \"CookieStore\"}}{{/crossLink}}) if it is not.\n\n  __This is the default store that Ember Simple Auth will use when the\n  application doesn't define a custom store.__\n\n  __This session store does not work with FastBoot. In order to use Ember\n  Simple Auth with FastBoot, configure the\n  {{#crossLink \"CookieStore\"}}{{/crossLink}} as the application's session\n  store.__\n\n  @class AdaptiveStore\n  @module ember-simple-auth/session-stores/adaptive\n  @extends BaseStore\n  @public\n*/\nexport default Base.extend({\n  /**\n    The `localStorage` key the store persists data in if `localStorage` is\n    available.\n\n    @property localStorageKey\n    @type String\n    @default 'ember_simple_auth-session'\n    @public\n  */\n  localStorageKey: 'ember_simple_auth-session',\n\n  /**\n    The domain to use for the cookie if `localStorage` is not available, e.g.,\n    \"example.com\", \".example.com\" (which includes all subdomains) or\n    \"subdomain.example.com\". If not explicitly set, the cookie domain defaults\n    to the domain the session was authenticated on.\n\n    @property cookieDomain\n    @type String\n    @default null\n    @public\n  */\n  _cookieDomain: null,\n  cookieDomain: proxyToInternalStore(),\n\n  /**\n    The name of the cookie to use if `localStorage` is not available.\n\n    @property cookieName\n    @type String\n    @default ember_simple_auth-session\n    @public\n  */\n  _cookieName: 'ember_simple_auth-session',\n  cookieName: proxyToInternalStore(),\n\n  /**\n    The path to use for the cookie, e.g., \"/\", \"/something\".\n\n    @property cookiePath\n    @type String\n    @default '/'\n    @public\n  */\n  _cookiePath: '/',\n  cookiePath: proxyToInternalStore(),\n\n  /**\n    The expiration time for the cookie in seconds if `localStorage` is not\n    available. A value of `null` will make the cookie a session cookie that\n    expires and gets deleted when the browser is closed.\n\n    @property cookieExpirationTime\n    @default null\n    @type Integer\n    @public\n  */\n  _cookieExpirationTime: null,\n  cookieExpirationTime: proxyToInternalStore(),\n\n  _cookies: service('cookies'),\n\n  _fastboot: computed(function() {\n    let owner = getOwner(this);\n\n    return owner && owner.lookup('service:fastboot');\n  }),\n\n  _isLocalStorageAvailable: computed(function() {\n    try {\n      localStorage.setItem(LOCAL_STORAGE_TEST_KEY, true);\n      localStorage.removeItem(LOCAL_STORAGE_TEST_KEY);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }),\n\n  init() {\n    this._super(...arguments);\n\n    let store;\n    if (this.get('_isLocalStorageAvailable')) {\n      const options = { key: this.get('localStorageKey') };\n      options._isFastBoot = false;\n      store = this._createStore(LocalStorage, options);\n    } else {\n      const options = this.getProperties('cookieDomain', 'cookieName', 'cookieExpirationTime', 'cookiePath');\n      options._fastboot = this.get('_fastboot');\n      options._cookies = this.get('_cookies');\n\n      store = this._createStore(Cookie, options);\n      this.set('cookieExpirationTime', store.get('cookieExpirationTime'));\n    }\n    this.set('_store', store);\n  },\n\n  _createStore(storeType, options) {\n    const store = storeType.create(options);\n\n    store.on('sessionDataUpdated', (data) => {\n      this.trigger('sessionDataUpdated', data);\n    });\n    return store;\n  },\n\n  /**\n    Persists the `data` in the `localStorage` if it is available or in a cookie\n    if it is not.\n\n    @method persist\n    @param {Object} data The data to persist\n    @return {Ember.RSVP.Promise} A promise that resolves when the data has successfully been persisted and rejects otherwise.\n    @public\n  */\n  persist() {\n    return this.get('_store').persist(...arguments);\n  },\n\n  /**\n    Returns all data currently stored in the `localStorage` if that is\n    available - or if it is not, in the cookie - as a plain object.\n\n    @method restore\n    @return {Ember.RSVP.Promise} A promise that resolves with the data currently persisted in the store when the data has been restored successfully and rejects otherwise.\n    @public\n  */\n  restore() {\n    return this.get('_store').restore();\n  },\n\n  /**\n    Clears the store by deleting the\n    {{#crossLink \"LocalStorageStore/key:property\"}}{{/crossLink}} from\n    `localStorage` if that is available or by deleting the cookie if it is not.\n\n    @method clear\n    @return {Ember.RSVP.Promise} A promise that resolves when the store has been cleared successfully and rejects otherwise.\n    @public\n  */\n  clear() {\n    return this.get('_store').clear();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/session-stores/base.js":"import Ember from 'ember';\n\nconst { RSVP, Object: EmberObject, Evented } = Ember;\n\n/**\n  The base class for all session stores. __This serves as a starting point for\n  implementing custom session stores and must not be used directly.__\n\n  Session Stores persist the session's state so that it survives a page reload\n  and is synchronized across multiple tabs or windows of the same application.\n\n  @class BaseStore\n  @module ember-simple-auth/session-stores/base\n  @extends Ember.Object\n  @uses Ember.Evented\n  @public\n*/\nexport default EmberObject.extend(Evented, {\n  /**\n    Triggered when the session store's data changes due to an external event,\n    e.g., from another tab or window of the same application. The session\n    handles that event, passes the updated data to its authenticator's\n    {{#crossLink \"BaseAuthenticator/restore:method\"}}{{/crossLink}} method and\n    handles the result of that invocation accordingly.\n\n    @event sessionDataUpdated\n    @param {Object} data The updated session data\n    @public\n  */\n\n  /**\n    Persists the `data`. This replaces all currently stored data.\n\n    `BaseStores`'s implementation always returns a rejecting promise. __This\n    method must be overridden in subclasses__.\n\n    @method persist\n    @param {Object} data The data to persist\n    @return {Ember.RSVP.Promise} A promise that resolves when the data has successfully been persisted and rejects otherwise.\n    @public\n  */\n  persist() {\n    return RSVP.reject();\n  },\n\n  /**\n    Returns all data currently stored as a plain object.\n\n    `BaseStores`'s implementation always returns a rejecting promise. __This\n    method must be overridden in subclasses__.\n\n    @method restore\n    @return {Ember.RSVP.Promise} A promise that resolves with the data currently persisted in the store when the data has been restored successfully and rejects otherwise.\n    @public\n  */\n  restore() {\n    return RSVP.reject();\n  },\n\n  /**\n    Clears the store.\n\n    `BaseStores`'s implementation always returns a rejecting promise. __This\n    method must be overridden in subclasses__.\n\n    @method clear\n    @return {Ember.RSVP.Promise} A promise that resolves when the store has been cleared successfully and rejects otherwise.\n    @public\n  */\n  clear() {\n    return RSVP.reject();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/session-stores/cookie.js":"import Ember from 'ember';\nimport BaseStore from './base';\nimport objectsAreEqual from '../utils/objects-are-equal';\n\nconst {\n  RSVP,\n  computed,\n  inject: { service },\n  run: { next, scheduleOnce, cancel, later },\n  isEmpty,\n  typeOf,\n  testing,\n  isPresent,\n  A,\n  getOwner,\n  warn,\n} = Ember;\n\nconst persistingProperty = function(beforeSet = function() {}) {\n  return computed({\n    get(key) {\n      return this.get(`_${key}`);\n    },\n    set(key, value) {\n      beforeSet.apply(this, [key, value]);\n      this.set(`_${key}`, value);\n      scheduleOnce('actions', this, this.rewriteCookie);\n      return value;\n    }\n  });\n};\n\n/**\n  Session store that persists data in a cookie.\n\n  By default the cookie session store uses a session cookie that expires and is\n  deleted when the browser is closed. The cookie expiration period can be\n  configured by setting the\n  {{#crossLink \"CookieStore/cookieExpirationTime:property\"}}{{/crossLink}}\n  property. This can be used to implement \"remember me\" functionality that will\n  either store the session persistently or in a session cookie depending on\n  whether the user opted in or not:\n\n  ```js\n  // app/controllers/login.js\n  export default Ember.Controller.extend({\n    rememberMe: false,\n\n    _rememberMeChanged: Ember.observer('rememberMe', function() {\n      const expirationTime = this.get('rememberMe') ? (14 * 24 * 60 * 60) : null;\n      this.set('session.store.cookieExpirationTime', expirationTime);\n    }\n  });\n  ```\n\n  __Applications that use FastBoot must use this session store by defining the\n  application session store like this:__\n\n  ```js\n  // app/session-stores/application.js\n  import CookieStore from 'ember-simple-auth/session-stores/cookie';\n\n  export default CookieStore.extend();\n  ```\n\n  @class CookieStore\n  @module ember-simple-auth/session-stores/cookie\n  @extends BaseStore\n  @public\n*/\nexport default BaseStore.extend({\n  _syncDataTimeout: null,\n  _renewExpirationTimeout: null,\n\n  /**\n    The domain to use for the cookie, e.g., \"example.com\", \".example.com\"\n    (which includes all subdomains) or \"subdomain.example.com\". If not\n    explicitly set, the cookie domain defaults to the domain the session was\n    authenticated on.\n\n    @property cookieDomain\n    @type String\n    @default null\n    @public\n  */\n  _cookieDomain: null,\n  cookieDomain: persistingProperty(),\n\n  /**\n    The name of the cookie.\n\n    @property cookieName\n    @type String\n    @default ember_simple_auth-session\n    @public\n  */\n  _cookieName: 'ember_simple_auth-session',\n  cookieName: persistingProperty(function() {\n    this._oldCookieName = this._cookieName;\n  }),\n\n  /**\n    The path to use for the cookie, e.g., \"/\", \"/something\".\n\n    @property cookiePath\n    @type String\n    @default '/'\n    @public\n  */\n  _cookiePath: '/',\n  cookiePath: persistingProperty(),\n\n  /**\n    The expiration time for the cookie in seconds. A value of `null` will make\n    the cookie a session cookie that expires and gets deleted when the browser\n    is closed.\n\n    The recommended minimum value is 90 seconds. If your value is less than\n    that, the cookie may expire before its expiration time is extended\n    (expiration time is extended every 60 seconds).\n\n    @property cookieExpirationTime\n    @default null\n    @type Integer\n    @public\n  */\n  _cookieExpirationTime: null,\n  cookieExpirationTime: persistingProperty(function(key, value) {\n    if (value < 90) {\n      this._warn('The recommended minimum value for `cookieExpirationTime` is 90 seconds. If your value is less than that, the cookie may expire before its expiration time is extended (expiration time is extended every 60 seconds).', false, { id: 'ember-simple-auth.cookieExpirationTime' });\n    }\n  }),\n\n  _cookies: service('cookies'),\n\n  _fastboot: computed(function() {\n    let owner = getOwner(this);\n\n    return owner && owner.lookup('service:fastboot');\n  }),\n\n  _secureCookies: computed(function() {\n    if (this.get('_fastboot.isFastBoot')) {\n      return this.get('_fastboot.request.protocol') === 'https';\n    }\n\n    return window.location.protocol === 'https:';\n  }).volatile(),\n\n  _isPageVisible: computed(function() {\n    if (this.get('_fastboot.isFastBoot')) {\n      return false;\n    } else {\n      const visibilityState = typeof document !== 'undefined' ? document.visibilityState || 'visible' : false;\n      return visibilityState === 'visible';\n    }\n  }).volatile(),\n\n  init() {\n    this._super(...arguments);\n\n    let cachedExpirationTime = this._read(`${this.get('cookieName')}-expiration_time`);\n    if (cachedExpirationTime) {\n      this.set('cookieExpirationTime', parseInt(cachedExpirationTime, 10));\n    }\n\n    if (!this.get('_fastboot.isFastBoot')) {\n      next(() => {\n        this._syncData().then(() => {\n          this._renewExpiration();\n        });\n      });\n    } else {\n      this._renew();\n    }\n  },\n\n  /**\n    Persists the `data` in the cookie.\n\n    @method persist\n    @param {Object} data The data to persist\n    @return {Ember.RSVP.Promise} A promise that resolves when the data has successfully been persisted and rejects otherwise.\n    @public\n  */\n  persist(data) {\n    this._lastData = data;\n    data = JSON.stringify(data || {});\n    let expiration = this._calculateExpirationTime();\n    this._write(data, expiration);\n    return RSVP.resolve();\n  },\n\n  /**\n    Returns all data currently stored in the cookie as a plain object.\n\n    @method restore\n    @return {Ember.RSVP.Promise} A promise that resolves with the data currently persisted in the store when the data has been restored successfully and rejects otherwise.\n    @public\n  */\n  restore() {\n    let data = this._read(this.get('cookieName'));\n    if (isEmpty(data)) {\n      return RSVP.resolve({});\n    } else {\n      return RSVP.resolve(JSON.parse(data));\n    }\n  },\n\n  /**\n    Clears the store by deleting the cookie.\n\n    @method clear\n    @return {Ember.RSVP.Promise} A promise that resolves when the store has been cleared successfully and rejects otherwise.\n    @public\n  */\n  clear() {\n    this._write('', 0);\n    this._lastData = {};\n    return RSVP.resolve();\n  },\n\n  _read(name) {\n    return this.get('_cookies').read(name) || '';\n  },\n\n  _calculateExpirationTime() {\n    let cachedExpirationTime = this._read(`${this.get('cookieName')}-expiration_time`);\n    cachedExpirationTime = cachedExpirationTime ? new Date().getTime() + cachedExpirationTime * 1000 : null;\n    return this.get('cookieExpirationTime') ? new Date().getTime() + this.get('cookieExpirationTime') * 1000 : cachedExpirationTime;\n  },\n\n  _write(value, expiration) {\n    let cookieOptions = {\n      domain: this.get('cookieDomain'),\n      expires: isEmpty(expiration) ? null : new Date(expiration),\n      path: this.get('cookiePath'),\n      secure: this.get('_secureCookies')\n    };\n    if (this._oldCookieName) {\n      A([this._oldCookieName, `${this._oldCookieName}-expiration_time`]).forEach((oldCookie) => {\n        this.get('_cookies').clear(oldCookie);\n      });\n      delete this._oldCookieName;\n    }\n    this.get('_cookies').write(this.get('cookieName'), value, cookieOptions);\n    if (!isEmpty(expiration)) {\n      let expirationCookieName = `${this.get('cookieName')}-expiration_time`;\n      let cachedExpirationTime = this.get('_cookies').read(expirationCookieName);\n      this.get('_cookies').write(expirationCookieName, this.get('cookieExpirationTime') || cachedExpirationTime, cookieOptions);\n    }\n  },\n\n  _syncData() {\n    return this.restore().then((data) => {\n      if (!objectsAreEqual(data, this._lastData)) {\n        this._lastData = data;\n        this.trigger('sessionDataUpdated', data);\n      }\n      if (!testing) {\n        cancel(this._syncDataTimeout);\n        this._syncDataTimeout = later(this, this._syncData, 500);\n      }\n    });\n  },\n\n  _renew() {\n    return this.restore().then((data) => {\n      if (!isEmpty(data) && data !== {}) {\n        data = typeOf(data) === 'string' ? data : JSON.stringify(data || {});\n        let expiration = this._calculateExpirationTime();\n        this._write(data, expiration);\n      }\n    });\n  },\n\n  _renewExpiration() {\n    if (!testing) {\n      cancel(this._renewExpirationTimeout);\n      this._renewExpirationTimeout = later(this, this._renewExpiration, 60000);\n    }\n    if (this.get('_isPageVisible')) {\n      return this._renew();\n    } else {\n      return RSVP.resolve();\n    }\n  },\n\n  rewriteCookie() {\n    // if `cookieName` has not been renamed, `oldCookieName` will be nil\n    const cookieName = this._oldCookieName || this._cookieName;\n    const data = this._read(cookieName);\n    if (isPresent(data)) {\n      const expiration = this._calculateExpirationTime();\n      this._write(data, expiration);\n    }\n  },\n\n  _warn() {\n    warn(...arguments);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/session-stores/ephemeral.js":"import Ember from 'ember';\nimport BaseStore from './base';\n\nconst { RSVP } = Ember;\n\n/**\n  Session store that __persists data in memory and thus is not actually\n  persistent__. It does also not synchronize the session's state across\n  multiple tabs or windows as those cannot share memory. __This store is mainly\n  useful for testing and will automatically be used when running tests.__\n\n  @class EphemeralStore\n  @module ember-simple-auth/session-stores/ephemeral\n  @extends BaseStore\n  @public\n*/\nexport default BaseStore.extend({\n  init() {\n    this._super(...arguments);\n    this.clear();\n  },\n\n  /**\n    Persists `data`. This replaces all currently stored data.\n\n    @method persist\n    @param {Object} data The data to persist\n    @return {Ember.RSVP.Promise} A promise that resolves when the data has successfully been persisted and rejects otherwise.\n    @public\n  */\n  persist(data) {\n    this._data = JSON.stringify(data || {});\n\n    return RSVP.resolve();\n  },\n\n  /**\n    Returns all data currently stored as a plain object.\n\n    @method restore\n    @return {Ember.RSVP.Promise} A promise that resolves with the data currently persisted in the store when the data has been restored successfully and rejects otherwise.\n    @public\n  */\n  restore() {\n    const data = JSON.parse(this._data) || {};\n\n    return RSVP.resolve(data);\n  },\n\n  /**\n    Clears the store.\n\n    @method clear\n    @return {Ember.RSVP.Promise} A promise that resolves when the store has been cleared successfully and rejects otherwise.\n    @public\n  */\n  clear() {\n    delete this._data;\n    this._data = '{}';\n\n    return RSVP.resolve();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/session-stores/local-storage.js":"/* global localStorage */\nimport Ember from 'ember';\nimport BaseStore from './base';\nimport objectsAreEqual from '../utils/objects-are-equal';\n\nconst { RSVP, $: jQuery, computed, getOwner } = Ember;\n\n/**\n  Session store that persists data in the browser's `localStorage`.\n\n  __`localStorage` is not available in Safari when running in private mode. In\n  general it is better to use the\n  {{#crossLink \"AdaptiveStore\"}}{{/crossLink}} that automatically falls back to\n  the {{#crossLink \"CookieStore\"}}{{/crossLink}} when `localStorage` is not\n  available.__\n\n  __This session store does not work with FastBoot. In order to use Ember\n  Simple Auth with FastBoot, configure the\n  {{#crossLink \"CookieStore\"}}{{/crossLink}} as the application's session\n  store.__\n\n  @class LocalStorageStore\n  @module ember-simple-auth/session-stores/local-storage\n  @extends BaseStore\n  @public\n*/\nexport default BaseStore.extend({\n  _isFastBoot: computed(function() {\n    const fastboot = getOwner(this).lookup('service:fastboot');\n\n    return fastboot ? fastboot.get('isFastBoot') : false;\n  }),\n\n  /**\n    The `localStorage` key the store persists data in.\n\n    @property key\n    @type String\n    @default 'ember_simple_auth-session'\n    @public\n  */\n  key: 'ember_simple_auth-session',\n\n  init() {\n    this._super(...arguments);\n\n    if (!this.get('_isFastBoot')) {\n      this._bindToStorageEvents();\n    }\n  },\n\n  /**\n    Persists the `data` in the `localStorage`.\n\n    @method persist\n    @param {Object} data The data to persist\n    @return {Ember.RSVP.Promise} A promise that resolves when the data has successfully been persisted and rejects otherwise.\n    @public\n  */\n  persist(data) {\n    this._lastData = data;\n    data = JSON.stringify(data || {});\n    localStorage.setItem(this.key, data);\n\n    return RSVP.resolve();\n  },\n\n  /**\n    Returns all data currently stored in the `localStorage` as a plain object.\n\n    @method restore\n    @return {Ember.RSVP.Promise} A promise that resolves with the data currently persisted in the store when the data has been restored successfully and rejects otherwise.\n    @public\n  */\n  restore() {\n    let data = localStorage.getItem(this.key);\n\n    return RSVP.resolve(JSON.parse(data) || {});\n  },\n\n  /**\n    Clears the store by deleting the\n    {{#crossLink \"LocalStorageStore/key:property\"}}{{/crossLink}} from\n    `localStorage`.\n\n    @method clear\n    @return {Ember.RSVP.Promise} A promise that resolves when the store has been cleared successfully and rejects otherwise.\n    @public\n  */\n  clear() {\n    localStorage.removeItem(this.key);\n    this._lastData = {};\n\n    return RSVP.resolve();\n  },\n\n  _bindToStorageEvents() {\n    jQuery(window).on('storage', (e) => {\n      if (e.originalEvent.key === this.key) {\n        this.restore().then((data) => {\n          if (!objectsAreEqual(data, this._lastData)) {\n            this._lastData = data;\n            this.trigger('sessionDataUpdated', data);\n          }\n        });\n      }\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/utils/inject.js":"export default function(registry, factoryNameOrType, property, injectionName) {\n  const inject = registry.inject || registry.injection;\n  inject.call(registry, factoryNameOrType, property, injectionName);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/utils/lookup.js":"export default function(instance, factoryName) {\n  if (instance.lookup) {\n    return instance.lookup(factoryName);\n  } else {\n    return instance.container.lookup(factoryName);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/addon/utils/objects-are-equal.js":"export default function objectsAreEqual(a, b) {\n  function compare(x, y) {\n    let property;\n    if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\n      return true;\n    }\n\n    if (x === y) {\n      return true;\n    }\n\n    if (!(x instanceof Object && y instanceof Object)) {\n      return false;\n    }\n\n    for (property in y) {\n      if (y.hasOwnProperty(property) !== x.hasOwnProperty(property)) {\n        return false;\n      } else if (typeof y[property] !== typeof x[property]) {\n        return false;\n      }\n    }\n\n    for (property in x) {\n      if (y.hasOwnProperty(property) !== x.hasOwnProperty(property)) {\n        return false;\n      } else if (typeof y[property] !== typeof x[property]) {\n        return false;\n      }\n\n      switch (typeof (x[property])) {\n        case 'object':\n          if (!compare(x[property], y[property])) {\n            return false;\n          }\n          break;\n        default:\n          if (x[property] !== y[property]) {\n            return false;\n          }\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  return compare(a, b);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/app/initializers/ember-simple-auth.js":"import ENV from '../config/environment';\nimport Configuration from 'ember-simple-auth/configuration';\nimport setupSession from 'ember-simple-auth/initializers/setup-session';\nimport setupSessionService from 'ember-simple-auth/initializers/setup-session-service';\n\nexport default {\n  name: 'ember-simple-auth',\n\n  initialize(registry) {\n    const config = ENV['ember-simple-auth'] || {};\n    config.baseURL = ENV.rootURL || ENV.baseURL;\n    Configuration.load(config);\n\n    setupSession(registry);\n    setupSessionService(registry);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/app/instance-initializers/ember-simple-auth.js":"import setupSessionRestoration from 'ember-simple-auth/instance-initializers/setup-session-restoration';\n\nexport default {\n  name: 'ember-simple-auth',\n\n  initialize(instance) {\n    setupSessionRestoration(instance);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/app/routes/application.js":"import Ember from 'ember';\n\nconst { Route } = Ember;\n\n// Ensure the application route exists for ember-simple-auth's `setup-session-restoration` initializer\nexport default Route.extend();\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/app/services/session.js":"import SessionService from 'ember-simple-auth/services/session';\n\nexport default SessionService;\n","/home/travis/build/npmtest/node-npmtest-ember-simple-auth/node_modules/ember-simple-auth/app/session-stores/application.js":"import Adaptive from 'ember-simple-auth/session-stores/adaptive';\n\nexport default Adaptive.extend();\n"}